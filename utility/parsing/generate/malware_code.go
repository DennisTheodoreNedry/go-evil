package generate

import (
	"fmt"

	"github.com/DennisTheodoreNedry/go-evil/utility/structure/functions"
	"github.com/DennisTheodoreNedry/go-evil/utility/structure/json"
	notify "github.com/DennisTheodoreNedry/notify_handler"
)

// Filters each definied function into the two categories, boot and loop (call functions aren't handled here)
func filter_function_types(data_object *json.Json_t) {

	for _, d_func := range data_object.Functions {

		// Identify the function type
		switch d_func.Func_type {
		case "boot":
			data_object.Add_boot_function(d_func.Name)

		case "loop":
			data_object.Add_loop_function(d_func.Name)

		case "end":
			data_object.Add_end_function(d_func.Name)

		}

	}

}

// Converts each sub function into a corresponding set of golang code
// Creates all functions, loop, boot and call
func Generate_go_functions(data_object *json.Json_t) {

	filter_function_types(data_object)

	// For each of our functions
	for _, d_func := range data_object.Functions {
		body := []string{}
		function_type := ""
		return_type := ""

		// Define the header
		if d_func.Func_type == "c" { // it's a call function

			switch d_func.Return_type { // Let's check the return type
			case "string":
				function_type = "string"

			case "boolean":
				function_type = "bool"

			case "integer":
				function_type = "int"

			case "null":
				function_type = ""

			default:
				notify.Error(fmt.Sprintf("Unknown return type '%s'", d_func.Return_type), "function_construction.generate_go_functions()", 1)
			}

		}

		converted_code := Generate_golang_code(d_func.Gut, data_object) // Generate the body code

		body = append(body, converted_code...)

		switch d_func.Return_type {
		case "string":
			return_type = "string"

		case "boolean":
			return_type = "bool"

		case "integer":
			return_type = "int"

		}

		data_object.Add_go_function(functions.Go_func_t{Name: d_func.Name, Func_type: function_type, Part_of_struct: "", Return_type: return_type, Parameters: []string{}, Gut: body})
	}

}
